<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="images/favicon.ico" type="image/x-icon">
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <title>BlockModes - Voxel Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: #1a1a2e;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Main Menu */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color:#1a1a2e ;
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #mainMenu::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            z-index: 0;
            opacity: 0.3;
            pointer-events: none;
        }

        .logo {
            max-width: 400px;
            width: 60%;
            height: auto;
            margin-bottom: 40px;
            position: relative;
            z-index: 1;
        }

        .navbar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1001;
        }

        .account-display {
            color: white;
            font-size: 18px;
            background: #1a1a2e;
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .online-indicator {
            width: 10px;
            height: 10px;
            background: #4CAF50;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .nav-btn {
            color: white;
            text-decoration: none;
            font-size: 16px;
            background: rgba(52, 152, 219, 0.6);
            padding: 10px 25px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
        }

        .nav-btn:hover {
            background: rgba(52, 152, 219, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .about-btn {
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 1001;
        }

        .updates-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1001;
        }

        .mode-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 800px;
            position: relative;
            z-index: 1;
        }

        .mode-card {
            background: #1a1a2e;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
        }

        .mode-card:hover {
            transform: translateY(-8px);
            background: #1a1a2e;
            box-shadow: 0 8px 32px rgb(186, 187, 255);
        }

        .mode-card h2 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .mode-card p {
            font-size: 14px;
            opacity: 0.9;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        #hud.active {
            display: block;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }

        .crosshair::after {
            height: 2px;
            width: 20px;
            top: 9px;
        }

        .hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            pointer-events: all;
        }

        .hotbar-slot {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hotbar-slot.active {
            border-color: white;
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }

        .health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 5px;
        }

        .heart {
            width: 30px;
            height: 30px;
            background: #e74c3c;
            clip-path: polygon(50% 20%, 61% 8%, 75% 8%, 86% 20%, 86% 36%, 50% 80%, 14% 36%, 14% 20%, 25% 8%, 39% 8%);
        }

        .heart.empty {
            background: rgba(231, 76, 60, 0.3);
        }

        /* Pause Menu */
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 999;
        }

        #pauseMenu.active {
            display: flex;
        }

        #pauseMenu h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 40px;
        }

        .menu-btn {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            padding: 15px 40px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }

        .menu-btn:hover {
            background: rgba(255,255,255,0.25);
            transform: scale(1.05);
        }

        .info-text {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            text-align: right;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
        }

        .hidden {
            display: none !important;
        }

        /* Players List */
        .players-list {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 12px;
            color: white;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
        }

        .players-list h3 {
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
        }

        .player-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-item.me {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid #4CAF50;
        }

        .player-avatar {
            width: 8px;
            height: 8px;
            background: #4CAF50;
            border-radius: 50%;
        }

        /* Connection Status */
        .connection-status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4CAF50;
        }

        .status-dot.disconnected {
            background: #e74c3c;
        }

        /* Updates Modal */
        #updatesModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #updatesModal.active {
            display: flex;
        }

        .updates-content {
            background: rgba(25, 25, 40, 0.95);
            border: 2px solid rgba(93, 173, 226, 0.5);
            border-radius: 16px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            color: white;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .updates-content h2 {
            font-size: 32px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }

        .update-entry {
            margin-bottom: 20px;
        }

        .update-entry h3 {
            color: #5DADE2;
            margin-bottom: 5px;
        }

        .update-entry ul {
            list-style-position: inside;
            color: rgba(255,255,255,0.8);
            margin-left: 10px;
        }

        .close-updates-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-updates-btn:hover {
            color: white;
        }

        /* Player Nametag */
        .player-nametag {
            position: absolute;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            transform: translate(-50%, -100%);
        }

        /* Creative Inventory */
        #creativeInventory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(25, 25, 40, 0.95);
            border: 2px solid rgba(93, 173, 226, 0.5);
            border-radius: 16px;
            padding: 30px;
            width: 600px;
            max-width: 90%;
            max-height: 80vh;
            display: none;
            flex-direction: column;
            z-index: 2000;
            color: white;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        #creativeInventory.active {
            display: flex;
        }

        #creativeInventory h2 {
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
            font-size: 24px;
            color: #5DADE2;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 10px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .inventory-slot {
            width: 100%;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            word-break: break-word;
            padding: 5px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }

        .inventory-slot:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #5DADE2;
            transform: scale(1.05);
        }

        .inventory-hint {
            text-align: center;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 15px;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Main Menu -->
    <div id="mainMenu">
        <nav class="navbar">
            <div id="accountDisplay" class="account-display">
                <div class="online-indicator"></div>
                <span>Account: Guest</span>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="logoutBtn" class="nav-btn">Logout</button>
                <a href="login.html" class="nav-btn" id="loginLink">Login</a>
            </div>
        </nav>
        <div style="display: flex; gap: 10px;">
                <button id="logoutBtn" class="nav-btn">Logout</button>
                <a href="about.html" class="about-btn nav-btn" id="aboutLink">Credits</a>
            </div>
        <button id="updatesBtn" class="nav-btn updates-btn">Stories</button>
        <button id="updatesBtn" class="nav-btn updates-btn">Updates</button>
        <img src="images/logo.png" class="logo" alt="BlockModes Logo">
        <div class="mode-grid">
        
            <div class="mode-card" data-mode="creative">
                <h2>üß± Creative</h2>
                <p>Unlimited blocks, flying, instant break. Build without limits.</p>
            </div>
            <div class="mode-card" data-mode="survival">
                <h2>‚öîÔ∏è Survival</h2>
                <p>Gather resources, manage health, survive the night.</p>
            </div>
            <div class="mode-card" data-mode="skyblock">
                <h2>üèùÔ∏è Skyblock</h2>
                <p>Start on a floating island. Expand carefully.</p>
            </div>
            <div class="mode-card" data-mode="parkour">
                <h2>üß© Parkour</h2>
                <p>Jump through challenging courses. Speed is key.</p>
            </div>
            <div class="mode-card" data-mode="battlemodes">
                <h2>‚öîÔ∏è BattleModes</h2>
                <p>Create nations, build borders, fight for territory!</p>
            </div>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="crosshair"></div>
        
        <div class="hotbar">
            <div class="hotbar-slot active" data-slot="0">Grass</div>
            <div class="hotbar-slot" data-slot="1">Stone</div>
            <div class="hotbar-slot" data-slot="2">Dirt</div>
            <div class="hotbar-slot" data-slot="3">Wood</div>
            <div class="hotbar-slot" data-slot="4">Gold</div>
        </div>

        <div class="health-bar">
            <div class="heart"></div>
            <div class="heart"></div>
            <div class="heart"></div>
            <div class="heart"></div>
            <div class="heart"></div>
        </div>

        <div class="info-text">
            <div id="modeInfo">Mode: Creative</div>
            <div>Position: <span id="posInfo">0, 0, 0</span></div>
            <div>FPS: <span id="fpsInfo">60</span></div>
        </div>

        <!-- Players List -->
        <div class="players-list">
            <h3>üåê Online Players (<span id="playerCount">1</span>)</h3>
            <div id="playersList"></div>
        </div>

        <!-- Connection Status -->
        <div class="connection-status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Connected</span>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <h1>PAUSED</h1>
        <button class="menu-btn" id="resumeBtn">Resume Game</button>
        <button class="menu-btn" id="mainMenuBtn">Main Menu</button>
    </div>

    <!-- Creative Inventory -->
    <div id="creativeInventory">
        <h2>Creative Inventory</h2>
        <div class="inventory-grid" id="inventoryGrid"></div>
        <div class="inventory-hint">Press TAB to close ‚Ä¢ Click item to set to hotbar</div>
    </div>

    <!-- Updates Modal -->
    <div id="updatesModal">
        <div class="updates-content">
            <button class="close-updates-btn" id="closeUpdatesBtn">√ó</button>
            <h2>Latest Stories</h2>
            
            <div class="update-entry">
                <ul>
                    <li>Added multiplayer support - play with friends!</li>
                    <li>See other players in real-time</li>
                    <li>New Gold block with texture</li>
                    <li>Persistent login system</li>
                    <li>Online player list</li>
                </ul>
                <h3>The Gold Update</h3>
                <img src="images/gold-update.png" alt="Gold Update" style="width: 100%; border-radius: 8px; margin: 10px 0;">
                <p>Check out the shiny new Gold block! We've added a custom texture to make it look even better. Use it to build luxurious structures and show off your wealth to other players in the game.</p>
            </div>
            
            <div class="update-entry">
                <ul>
                    <li>Added Creative, Survival, Skyblock modes</li>
                    <li>New BattleModes with Nation system</li>
                    <li>Improved Parkour mechanics</li>
                    <li>Account system and login</li>
                </ul>
                <h3>Terrain Update</h3>
                <img src="images/terrain-update.png" alt="Terrain Update" style="width: 100%; border-radius: 8px; margin: 10px 0;">
                <p>We have completely revamped the terrain generation. Explore smoother hills, more interesting landscapes, and better biomes. The world is now more fun to explore and build in!</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        // ===========================================
        // MULTIPLAYER SYSTEM
        // ===========================================
        class MultiplayerManager {
            constructor() {
                this.players = new Map();
                this.socket = io("http://localhost:3000");
                
                const storedData = localStorage.getItem('blockmodesPlayer');
                const username = storedData ? JSON.parse(storedData).username : 'Guest';

                this.socket = io("http://localhost:3000", { query: { username } });
                this.updateInterval = null;
                this.syncInterval = 50;
                this.connected = false;
                
                this.init();
            }

            init() {
                this.socket.on("connect", () => {
                    this.updateConnectionStatus(true);
                    this.startSync();
                });

                this.socket.on("disconnect", () => {
                    this.updateConnectionStatus(false);
                    this.stopSync();
                });

                // when you join
                this.socket.on("currentPlayers", players => {
                    for (const id in players) {
                        if (id === this.socket.id) continue;
                        this.addRemotePlayer(id, players[id]);
                    }
                    this.updatePlayersList();
                });

                // when new player joins
                this.socket.on("playerJoined", ({ id, data }) => {
                    this.addRemotePlayer(id, data);
                    this.updatePlayersList();
                });

                // movement updates
                this.socket.on("playerMoved", ({ id, data }) => {
                    this.updateRemotePlayer(id, data);
                });

                // player leaves
                this.socket.on("playerLeft", id => {
                    this.removePlayer(id);
                    this.updatePlayersList();
                });
            }

            startSync() {
                if (this.updateInterval) clearInterval(this.updateInterval);
                this.updateInterval = setInterval(() => {
                    if (window.game && window.game.player && this.connected) {
                        const pos = window.game.player.position;
                        const rot = window.game.player.rotation;
                        this.socket.emit("playerUpdate", {
                            x: pos.x,
                            y: pos.y,
                            z: pos.z,
                            rotY: rot.y
                        });
                    }
                }, this.syncInterval);
            }

            stopSync() {
                if (this.updateInterval) clearInterval(this.updateInterval);
            }

            addRemotePlayer(id, data) {
                if (this.players.has(id)) return;
                
                if (window.game && window.game.scene) {
                    // Create new player mesh
                    const geometry = new THREE.BoxGeometry(0.6, 1.8, 0.6);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: this.getPlayerColor(id) 
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // Add nametag
                    mesh.userData.username = "Player " + id.substr(0, 4);
                    mesh.userData.username = data.username || ("Player " + id.substr(0, 4));
                    
                    window.game.scene.add(mesh);
                    this.players.set(id, mesh);
                    this.updateRemotePlayer(id, data);
                }
            }

            updateRemotePlayer(id, data) {
                const mesh = this.players.get(id);
                if (mesh) {
                    mesh.position.set(data.x, data.y, data.z);
                    mesh.rotation.y = data.rotY;
                }
            }

            removePlayer(id) {
                const mesh = this.players.get(id);
                if (mesh && window.game && window.game.scene) {
                    window.game.scene.remove(mesh);
                    this.players.delete(id);
                }
            }

            getPlayerColor(id) {
                const colors = [0xFF5252, 0x4CAF50, 0x2196F3, 0xFFC107, 0x9C27B0, 0xFF9800];
                const hash = id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                return colors[hash % colors.length];
            }

            updatePlayersList() {
                const playersList = document.getElementById('playersList');
                const playerCount = document.getElementById('playerCount');
                
                if (!playersList) return;

                playerCount.textContent = this.players.size + 1;

                let html = `
                    <div class="player-item me">
                        <div class="player-avatar" style="background: #4CAF50;"></div>
                        You
                    </div>
                `;

                this.players.forEach((mesh, id) => {
                    html += `
                        <div class="player-item">
                            <div class="player-avatar" style="background: ${this.getPlayerColor(id)};"></div>
                            Player ${id.substr(0, 4)}
                            ${mesh.userData.username}
                        </div>
                    `;
                });

                playersList.innerHTML = html;
            }

            updateConnectionStatus(connected) {
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                
                if (statusDot && statusText) {
                    this.connected = connected;
                    statusDot.className = 'status-dot' + (connected ? '' : ' disconnected');
                    statusText.textContent = connected ? 'Connected' : 'Disconnected';
                }
            }

            dispose() {
                this.stopSync();
                if (this.socket) this.socket.disconnect();
                
                this.players.forEach(mesh => {
                    if (window.game && window.game.scene) {
                        window.game.scene.remove(mesh);
                    }
                });
                this.players.clear();
            }
        }

        // ===========================================
        // GAME MODE SYSTEM
        // ===========================================
        const GameModes = {
            creative: {
                name: "Creative",
                allowFlying: true,
                breakSpeed: 0,
                placeSpeed: 0,
                startingBlocks: ['grass', 'stone', 'dirt', 'wood', 'leaves', 'sand', 'cactus', 'gold', 'silver'],
                gravity: 0.02,
                jumpForce: 0.15,
                spawnHeight: 50
            },
            survival: {
                name: "Survival",
                allowFlying: false,
                breakSpeed: 500,
                placeSpeed: 200,
                startingBlocks: [],
                hasHealth: true,
                maxHealth: 10,
                gravity: 0.02,
                jumpForce: 0.15,
                spawnHeight: 50
            },
            skyblock: {
                name: "Skyblock",
                allowFlying: false,
                breakSpeed: 500,
                placeSpeed: 200,
                startingBlocks: ['grass', 'stone', 'dirt'],
                hasHealth: true,
                maxHealth: 10,
                gravity: 0.02,
                jumpForce: 0.15,
                spawnHeight: 30,
                customTerrain: 'skyblock'
            },
            parkour: {
                name: "Parkour",
                allowFlying: false,
                breakSpeed: Infinity,
                placeSpeed: Infinity,
                startingBlocks: [],
                hasHealth: false,
                gravity: 0.025,
                jumpForce: 0.18,
                spawnHeight: 20,
                customTerrain: 'parkour'
            },
            battlemodes: {
                name: "BattleModes",
                allowFlying: false,
                breakSpeed: 500,
                placeSpeed: 200,
                startingBlocks: ['grass', 'stone', 'wood'],
                hasHealth: true,
                maxHealth: 10,
                gravity: 0.02,
                jumpForce: 0.15,
                spawnHeight: 50
            }
        };

        // ===========================================
        // BLOCK DEFINITIONS WITH GOLD TEXTURE
        // ===========================================
        const BlockTypes = {
            air: { name: 'Air', color: 0x000000, solid: false },
            grass: { name: 'Grass', color: 0x4CAF50, solid: true },
            stone: { name: 'Stone', color: 0x808080, solid: true },
            dirt: { name: 'Dirt', color: 0x8B4513, solid: true },
            wood: { name: 'Wood', color: 0xA0522D, solid: true },
            leaves: { name: 'Leaves', color: 0x228B22, solid: true },
            sand: { name: 'Sand', color: 0xE6C288, solid: true },
            cactus: { name: 'Cactus', color: 0x006400, solid: true },
            gold: { name: 'Gold', color: 0xFFD700, solid: true, hasTexture: true, texturePath: 'textures/gold.png' },
            silver: { name: 'Silver', color: 0xC0C0C0, solid: true, hasTexture: true, texturePath: 'textures/silver.png' },
            graphite: { name: 'Graphite', color: 0x444444, solid: true, hasTexture: true, texturePath: 'textures/graphite.png' },
            iron: { name: 'Iron', color: 0xEEEEEE, solid: true, hasTexture: true, texturePath: 'textures/iron.png' }
        };

        // ===========================================
        // TEXTURE LOADER
        // ===========================================
        class TextureManager {
            constructor() {
                this.loader = new THREE.TextureLoader();
                this.textures = new Map();
                this.loadTextures();
            }

            loadTextures() {
                Object.entries(BlockTypes).forEach(([key, block]) => {
                    if (block.hasTexture && block.texturePath) {
                        this.loader.load(
                            block.texturePath,
                            (texture) => {
                                texture.magFilter = THREE.NearestFilter;
                                texture.minFilter = THREE.NearestFilter;
                                this.textures.set(key, texture);
                            },
                            undefined,
                            (error) => {
                                console.warn(`Failed to load texture for ${key}:`, error);
                            }
                        );
                    }
                });
            }

            getTexture(blockType) {
                return this.textures.get(blockType);
            }

            getMaterial(blockType) {
                const block = BlockTypes[blockType];
                const texture = this.getTexture(blockType);
                
                if (texture) {
                    return new THREE.MeshLambertMaterial({ map: texture });
                } else {
                    return new THREE.MeshLambertMaterial({ color: block.color });
                }
            }
        }

        // ===========================================
        // GAME ENGINE CORE
        // ===========================================
        class Game {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.player = null;
                this.input = null;
                this.currentMode = null;
                this.paused = false;
                this.running = false;
                this.multiplayer = null;
                this.textureManager = null;
                
                this.init();
            }

            init() {
                this.setupRenderer();
                this.setupUI();
                this.textureManager = new TextureManager();
                this.setupCreativeInventory();
            }

            setupRenderer() {
                const canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);

                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
                dirLight.position.set(50, 100, 50);
                this.scene.add(dirLight);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300);

                window.addEventListener('resize', () => this.onResize());
            }

            setupUI() {
                // Check for stored login
                const storedData = localStorage.getItem('blockmodesPlayer');
                let username = 'Guest';
                let isLoggedIn = false;

                if (storedData) {
                    try {
                        const data = JSON.parse(storedData);
                        if (data.username) {
                            username = data.username;
                            isLoggedIn = true;
                        }
                    } catch (e) {
                        console.error('Error parsing stored player data');
                    }
                }

                // Update UI based on login status
                const accountDisplay = document.getElementById('accountDisplay');
                const loginLink = document.getElementById('loginLink');
                const logoutBtn = document.getElementById('logoutBtn');

                if (accountDisplay) {
                    accountDisplay.querySelector('span').textContent = `Account: ${username}`;
                }

                if (isLoggedIn) {
                    if (loginLink) loginLink.style.display = 'none';
                    if (logoutBtn) logoutBtn.style.display = 'block';
                } else {
                    if (loginLink) loginLink.style.display = 'block';
                    if (logoutBtn) logoutBtn.style.display = 'none';
                }

                // Logout functionality
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', () => {
                        localStorage.removeItem('blockmodesPlayer');
                        sessionStorage.removeItem('blockmodesPlayer');
                        window.location.reload();
                    });
                }

                // Mode selection
                document.querySelectorAll('.mode-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const mode = card.dataset.mode;
                        this.startGame(mode);
                    });
                });

                // Pause menu
                document.getElementById('resumeBtn').addEventListener('click', () => {
                    this.togglePause();
                });

                document.getElementById('mainMenuBtn').addEventListener('click', () => {
                    this.returnToMenu();
                });

                // Updates Modal
                const updatesModal = document.getElementById('updatesModal');
                const updatesBtn = document.getElementById('updatesBtn');
                const closeUpdatesBtn = document.getElementById('closeUpdatesBtn');

                updatesModal.classList.add('active');

                updatesBtn.addEventListener('click', () => {
                    updatesModal.classList.add('active');
                });

                closeUpdatesBtn.addEventListener('click', () => {
                    updatesModal.classList.remove('active');
                });

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && updatesModal.classList.contains('active')) {
                        updatesModal.classList.remove('active');
                    }
                });
            }

            setupCreativeInventory() {
                const grid = document.getElementById('inventoryGrid');
                grid.innerHTML = '';
                
                Object.entries(BlockTypes).forEach(([type, data]) => {
                    if (type === 'air') return;
                    
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';
                    slot.textContent = data.name;
                    
                    // Set background color based on block color
                    const hexColor = '#' + data.color.toString(16).padStart(6, '0');
                    slot.style.backgroundColor = hexColor;
                    
                    slot.addEventListener('click', () => {
                        if (this.player) {
                            this.player.setHotbarSlot(this.player.selectedSlot, type);
                        }
                    });
                    
                    grid.appendChild(slot);
                });
            }

            toggleCreativeInventory() {
                const inv = document.getElementById('creativeInventory');
                const isActive = inv.classList.contains('active');
                
                if (isActive) {
                    inv.classList.remove('active');
                    this.input.requestPointerLock();
                } else {
                    inv.classList.add('active');
                    this.input.exitPointerLock();
                }
            }

            startGame(modeName) {
                this.currentMode = GameModes[modeName];
                
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('hud').classList.add('active');
                document.getElementById('modeInfo').textContent = `Mode: ${this.currentMode.name}`;

                this.world = new World(this.scene, this.currentMode, this.textureManager);
                this.player = new Player(this.camera, this.currentMode, this.world, this);
                this.input = new InputManager(this.player, this);
                this.multiplayer = new MultiplayerManager();

                if (!this.currentMode.hasHealth) {
                    document.querySelector('.health-bar').style.display = 'none';
                } else {
                    document.querySelector('.health-bar').style.display = 'flex';
                }

                this.running = true;
                this.animate();
            }

            togglePause() {
                this.paused = !this.paused;
                const pauseMenu = document.getElementById('pauseMenu');
                
                if (this.paused) {
                    pauseMenu.classList.add('active');
                    this.input.exitPointerLock();
                } else {
                    pauseMenu.classList.remove('active');
                    this.input.requestPointerLock();
                }
            }

            returnToMenu() {
                this.running = false;
                this.paused = false;
                
                if (this.world) this.world.dispose();
                if (this.input) this.input.dispose();
                if (this.multiplayer) this.multiplayer.dispose();
                
                document.getElementById('pauseMenu').classList.remove('active');
                document.getElementById('hud').classList.remove('active');
                document.getElementById('mainMenu').classList.remove('hidden');
            }

            animate() {
                if (!this.running) return;

                requestAnimationFrame(() => this.animate());

                if (!this.paused) {
                    this.player.update();
                    this.world.update(this.player.position);
                    
                    const pos = this.player.position;
                    document.getElementById('posInfo').textContent = 
                        `${Math.floor(pos.x)}, ${Math.floor(pos.y)}, ${Math.floor(pos.z)}`;
                }

                this.renderer.render(this.scene, this.camera);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // ===========================================
        // WORLD / CHUNK SYSTEM
        // ===========================================
        class World {
            constructor(scene, mode, textureManager) {
                this.scene = scene;
                this.mode = mode;
                this.textureManager = textureManager;
                this.chunks = new Map();
                this.chunkSize = 16;
                this.renderDistance = 4;
                this.blockMeshes = new Map();
                
                this.generateInitialWorld();
            }

            generateInitialWorld() {
                for (let x = -this.renderDistance; x <= this.renderDistance; x++) {
                    for (let z = -this.renderDistance; z <= this.renderDistance; z++) {
                        this.generateChunk(x, z);
                    }
                }
            }

            generateChunk(cx, cz) {
                const key = `${cx},${cz}`;
                if (this.chunks.has(key)) return;

                const chunk = new Array(this.chunkSize);
                for (let x = 0; x < this.chunkSize; x++) {
                    chunk[x] = new Array(this.chunkSize);
                    for (let z = 0; z < this.chunkSize; z++) {
                        chunk[x][z] = new Array(64).fill('air');
                        
                        if (this.mode.customTerrain === 'skyblock') {
                            this.generateSkyblock(chunk, x, z, cx, cz);
                        } else if (this.mode.customTerrain === 'parkour') {
                            this.generateParkour(chunk, x, z, cx, cz);
                        } else {
                            this.generateTerrain(chunk, x, z, cx, cz);
                        }
                    }
                }

                if (!this.mode.customTerrain) {
                    this.decorateChunk(chunk, cx, cz);
                }

                this.chunks.set(key, chunk);
                this.renderChunk(cx, cz, chunk);
            }

            generateTerrain(chunk, lx, lz, cx, cz) {
                const wx = cx * this.chunkSize + lx;
                const wz = cz * this.chunkSize + lz;
                
                // Biome generation
                const biome = Math.sin(wx * 0.005) + Math.sin(wz * 0.005);
                
                let height;
                
                if (biome > -0.2) {
                    // Forest
                    height = 30 + Math.floor(
                        Math.sin(wx * 0.04) * 5 + 
                        Math.cos(wz * 0.04) * 5 +
                        Math.sin(wx * 0.01 + wz * 0.01) * 10
                    );
                    
                    for (let y = 0; y < height; y++) {
                        if (y === height - 1) {
                            chunk[lx][lz][y] = 'grass';
                        } else if (y > height - 4) {
                            chunk[lx][lz][y] = 'dirt';
                        } else if (Math.random() < 0.02 && y > height - 10) {
                            chunk[lx][lz][y] = 'gold';
                        } else {
                            chunk[lx][lz][y] = 'stone';
                        }
                    }
                } else {
                    // Desert
                    height = 30 + Math.floor(
                        Math.abs(Math.sin(wx * 0.03 + wz * 0.02)) * 10 +
                        Math.sin(wx * 0.01) * 5
                    );
                    
                    for (let y = 0; y < height; y++) {
                        if (y >= height - 4) {
                            chunk[lx][lz][y] = 'sand';
                        } else {
                            chunk[lx][lz][y] = 'stone';
                        }
                    }
                }
            }

            decorateChunk(chunk, cx, cz) {
                for (let x = 2; x < this.chunkSize - 2; x++) {
                    for (let z = 2; z < this.chunkSize - 2; z++) {
                        const wx = cx * this.chunkSize + x;
                        const wz = cz * this.chunkSize + z;
                        
                        const biome = Math.sin(wx * 0.005) + Math.sin(wz * 0.005);
                        
                        let surfaceY = -1;
                        for (let y = 63; y >= 0; y--) {
                            if (chunk[x][z][y] !== 'air') {
                                surfaceY = y;
                                break;
                            }
                        }
                        
                        if (surfaceY > 0 && surfaceY < 60) {
                            const rand = Math.abs(Math.sin(wx * 12.9898 + wz * 78.233) * 43758.5453) % 1;
                            
                            if (biome > -0.2) {
                                // Forest - Trees
                                if (rand < 0.02) {
                                    this.buildTree(chunk, x, z, surfaceY + 1);
                                }
                            } else {
                                // Desert - Cactus
                                if (rand < 0.01) {
                                    this.buildCactus(chunk, x, z, surfaceY + 1);
                                }
                            }
                        }
                    }
                }
            }

            buildTree(chunk, x, z, y) {
                const height = 4 + Math.floor(Math.random() * 2);
                
                // Trunk
                for (let i = 0; i < height; i++) {
                    if (y + i < 64) chunk[x][z][y + i] = 'wood';
                }
                
                // Leaves
                for (let lx = x - 2; lx <= x + 2; lx++) {
                    for (let lz = z - 2; lz <= z + 2; lz++) {
                        for (let ly = y + height - 2; ly <= y + height + 1; ly++) {
                            if (lx >= 0 && lx < this.chunkSize && lz >= 0 && lz < this.chunkSize && ly < 64) {
                                const dist = Math.abs(lx - x) + Math.abs(lz - z);
                                if (dist <= 1 || (ly < y + height && dist <= 2)) {
                                    if (chunk[lx][lz][ly] === 'air') {
                                        chunk[lx][lz][ly] = 'leaves';
                                    }
                                }
                            }
                        }
                    }
                }
            }

            buildCactus(chunk, x, z, y) {
                const height = 2 + Math.floor(Math.random() * 2);
                for (let i = 0; i < height; i++) {
                    if (y + i < 64) chunk[x][z][y + i] = 'cactus';
                    }
                }

            generateSkyblock(chunk, lx, lz, cx, cz) {
                if (cx === 0 && cz === 0 && lx < 5 && lz < 5) {
                    chunk[lx][lz][15] = 'grass';
                    chunk[lx][lz][14] = 'dirt';
                    chunk[lx][lz][13] = 'stone';
                    
                    if (lx === 2 && lz === 2) {
                        chunk[lx][lz][16] = 'wood';
                    }
                }
            }

            generateParkour(chunk, lx, lz, cx, cz) {
                const wx = cx * this.chunkSize + lx;
                const wz = cz * this.chunkSize + lz;
                
                if (Math.abs(wx % 8) < 3 && Math.abs(wz % 8) < 3) {
                    const platformHeight = 10 + Math.floor(wx / 8) * 2;
                    chunk[lx][lz][platformHeight] = 'stone';
                }
            }

            renderChunk(cx, cz, chunk) {
                const group = new THREE.Group();
                const meshCache = new Map();

                for (let x = 0; x < this.chunkSize; x++) {
                    for (let z = 0; z < this.chunkSize; z++) {
                        for (let y = 0; y < chunk[x][z].length; y++) {
                            const blockType = chunk[x][z][y];
                            if (blockType === 'air') continue;

                            const wx = cx * this.chunkSize + x;
                            const wz = cz * this.chunkSize + z;

                            if (!this.isBlockExposed(wx, y, wz)) continue;

                            const key = blockType;

                            if (!meshCache.has(key)) {
                                const geo = new THREE.BoxGeometry(1, 1, 1);
                                const mat = this.textureManager.getMaterial(blockType);
                                meshCache.set(key, { geo, mat });
                            }

                            const { geo, mat } = meshCache.get(key);
                            const mesh = new THREE.Mesh(geo, mat);
                            mesh.position.set(wx, y, wz);
                            mesh.userData = { block: blockType, pos: { x: wx, y: y, z: wz } };
                            
                            group.add(mesh);
                            this.blockMeshes.set(`${wx},${y},${wz}`, mesh);
                        }
                    }
                }

                group.position.set(0, 0, 0);
                this.scene.add(group);
                this.chunks.set(`${cx},${cz}_mesh`, group);
            }

            isBlockExposed(x, y, z) {
                const neighbors = [
                    this.getBlock(x + 1, y, z),
                    this.getBlock(x - 1, y, z),
                    this.getBlock(x, y + 1, z),
                    this.getBlock(x, y - 1, z),
                    this.getBlock(x, y, z + 1),
                    this.getBlock(x, y, z - 1)
                ];
                return neighbors.some(b => b === 'air' || !b);
            }

            getBlock(x, y, z) {
                if (y < 0 || y >= 64) return 'air';
                
                const cx = Math.floor(x / this.chunkSize);
                const cz = Math.floor(z / this.chunkSize);
                const key = `${cx},${cz}`;
                
                const chunk = this.chunks.get(key);
                if (!chunk) return null;

                const lx = ((x % this.chunkSize) + this.chunkSize) % this.chunkSize;
                const lz = ((z % this.chunkSize) + this.chunkSize) % this.chunkSize;

                return chunk[lx][lz][y];
            }

            setBlock(x, y, z, blockType) {
                if (y < 0 || y >= 64) return false;
                
                const cx = Math.floor(x / this.chunkSize);
                const cz = Math.floor(z / this.chunkSize);
                const key = `${cx},${cz}`;
                
                const chunk = this.chunks.get(key);
                if (!chunk) return false;

                const lx = ((x % this.chunkSize) + this.chunkSize) % this.chunkSize;
                const lz = ((z % this.chunkSize) + this.chunkSize) % this.chunkSize;

                chunk[lx][lz][y] = blockType;
                
                const meshKey = `${x},${y},${z}`;
                const existingMesh = this.blockMeshes.get(meshKey);
                if (existingMesh) {
                    existingMesh.parent.remove(existingMesh);
                    this.blockMeshes.delete(meshKey);
                }

                if (blockType !== 'air') {
                    const geo = new THREE.BoxGeometry(1, 1, 1);
                    const mat = this.textureManager.getMaterial(blockType);
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x, y, z);
                    mesh.userData = { block: blockType, pos: { x, y, z } };
                    
                    const chunkMesh = this.chunks.get(`${cx},${cz}_mesh`);
                    if (chunkMesh) {
                        chunkMesh.add(mesh);
                        this.blockMeshes.set(meshKey, mesh);
                    }
                }

                return true;
            }

            update(playerPos) {}

            dispose() {
                this.chunks.forEach((value, key) => {
                    if (key.includes('_mesh')) {
                        this.scene.remove(value);
                    }
                });
                this.chunks.clear();
                this.blockMeshes.clear();
            }
        }

        // ===========================================
        // PLAYER CONTROLLER
        // ===========================================
        class Player {
            constructor(camera, mode, world, game) {
                this.camera = camera;
                this.mode = mode;
                this.world = world;
                this.game = game;
                
                this.position = new THREE.Vector3(0, mode.spawnHeight, 0);
                this.velocity = new THREE.Vector3();
                this.rotation = new THREE.Euler(0, 0, 0, 'YXZ');
                
                this.camera.rotation.order = 'YXZ';
                this.camera.position.copy(this.position);
                
                this.grounded = false;
                this.flying = false;
                this.health = mode.hasHealth ? mode.maxHealth : 0;
                this.selectedSlot = 0;

                this.raycaster = new THREE.Raycaster();
                this.raycaster.far = 10;

                this.inventory = new Array(5).fill(null).map(() => ({ type: 'air', count: 0 }));
                this.setupHotbar();
            }

            setupHotbar() {
                if (this.mode.startingBlocks) {
                    this.mode.startingBlocks.forEach((type, i) => {
                        if (i < 5) {
                            this.inventory[i] = { 
                                type: type, 
                                count: this.mode.name === 'Creative' ? Infinity : 64 
                            };
                        }
                    });
                }

                const slots = document.querySelectorAll('.hotbar-slot');
                slots.forEach((slot, i) => {
                    slot.addEventListener('click', () => this.selectSlot(i));
                });
                
                this.updateHotbarUI();
            }

            updateHotbarUI() {
                const slots = document.querySelectorAll('.hotbar-slot');
                slots.forEach((slot, i) => {
                    const item = this.inventory[i];
                    if (item.type !== 'air') {
                        const countDisplay = item.count === Infinity ? '‚àû' : item.count;
                        slot.textContent = `${BlockTypes[item.type].name} (${countDisplay})`;
                        slot.dataset.block = item.type;
                    } else {
                        slot.textContent = 'Empty';
                        slot.dataset.block = 'air';
                    }
                });
            }

            addToInventory(blockType) {
                let slotIndex = this.inventory.findIndex(item => item.type === blockType);
                
                if (slotIndex !== -1) {
                    if (this.inventory[slotIndex].count !== Infinity) {
                        this.inventory[slotIndex].count++;
                    }
                } else {
                    slotIndex = this.inventory.findIndex(item => item.type === 'air');
                    if (slotIndex !== -1) {
                        this.inventory[slotIndex] = { type: blockType, count: 1 };
                    }
                }
                this.updateHotbarUI();
            }

            setHotbarSlot(index, type) {
                this.inventory[index] = { 
                    type: type, 
                    count: this.mode.name === 'Creative' ? Infinity : 64 
                };
                this.updateHotbarUI();
            }

            selectSlot(index) {
                this.selectedSlot = index;
                document.querySelectorAll('.hotbar-slot').forEach((slot, i) => {
                    slot.classList.toggle('active', i === index);
                });
            }

            update() {
                this.applyPhysics();
                this.camera.position.copy(this.position);
                this.camera.rotation.copy(this.rotation);
            }

            applyPhysics() {
                if (!this.flying) {
                    this.velocity.y -= this.mode.gravity;
                }

                this.position.add(this.velocity);

                const blockBelow = this.world.getBlock(
                    Math.floor(this.position.x),
                    Math.floor(this.position.y - 1.8),
                    Math.floor(this.position.z)
                );

                if (blockBelow && BlockTypes[blockBelow].solid) {
                    this.grounded = true;
                    this.velocity.y = 0;
                    this.position.y = Math.ceil(this.position.y - 1.8) + 1.8;
                } else {
                    this.grounded = false;
                }

                this.velocity.x *= 0.9;
                this.velocity.z *= 0.9;
                if (this.flying) this.velocity.y *= 0.9;
            }

            move(direction) {
                const speed = this.flying ? 0.1 : 0.05;
                const forward = new THREE.Vector3(0, 0, -1).applyEuler(this.rotation);
                const right = new THREE.Vector3(1, 0, 0).applyEuler(this.rotation);

                if (direction === 'forward') {
                    this.velocity.add(forward.multiplyScalar(speed));
                }
                if (direction === 'back') {
                    this.velocity.add(forward.multiplyScalar(-speed));
                }
                if (direction === 'left') {
                    this.velocity.add(right.multiplyScalar(-speed));
                }
                if (direction === 'right') {
                    this.velocity.add(right.multiplyScalar(speed));
                }
            }

            jump() {
                if (this.grounded && !this.flying) {
                    this.velocity.y = this.mode.jumpForce;
                }
            }

            toggleFly() {
                if (this.mode.allowFlying) {
                    this.flying = !this.flying;
                    if (this.flying) {
                        this.velocity.y = 0;
                    }
                }
            }

            breakBlock() {
                const targetBlock = this.getTargetBlock();
                if (targetBlock) {
                    const blockType = this.world.getBlock(targetBlock.x, targetBlock.y, targetBlock.z);
                    if (blockType && blockType !== 'air') {
                        if (this.mode.name === 'Survival' || this.mode.name === 'Skyblock') {
                            this.addToInventory(blockType);
                        }
                        this.world.setBlock(targetBlock.x, targetBlock.y, targetBlock.z, 'air');
                    }
                }
            }

            placeBlock() {
                const targetBlock = this.getTargetBlock(true);
                if (targetBlock) {
                    const item = this.inventory[this.selectedSlot];
                    if (item.type !== 'air' && item.count > 0) {
                        if (this.world.setBlock(targetBlock.x, targetBlock.y, targetBlock.z, item.type)) {
                            if (item.count !== Infinity) {
                                item.count--;
                                if (item.count <= 0) {
                                    this.inventory[this.selectedSlot] = { type: 'air', count: 0 };
                                }
                                this.updateHotbarUI();
                            }
                        }
                    }
                }
            }

            getTargetBlock(adjacent = false) {
                this.raycaster.setFromCamera({ x: 0, y: 0 }, this.camera);
                
                const blockMeshes = Array.from(this.world.blockMeshes.values());
                const intersects = this.raycaster.intersectObjects(blockMeshes);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const p = hit.object.position;
                    
                    if (adjacent && hit.face) {
                        return {
                            x: p.x + hit.face.normal.x,
                            y: p.y + hit.face.normal.y,
                            z: p.z + hit.face.normal.z
                        };
                    }
                    
                    return { x: p.x, y: p.y, z: p.z };
                }
                
                return null;
            }
        }

        // ===========================================
        // INPUT MANAGER
        // ===========================================
        class InputManager {
            constructor(player, game) {
                this.player = player;
                this.game = game;
                this.keys = {};
                this.mouseDown = false;
                this.locked = false;

                this.setupEventListeners();
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                
                document.addEventListener('mousedown', (e) => this.onMouseDown(e));
                document.addEventListener('mouseup', () => this.mouseDown = false);
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('wheel', (e) => this.onWheel(e));
                
                document.addEventListener('click', () => {
                    if (!this.locked && document.getElementById('hud').classList.contains('active') && 
                        !document.getElementById('creativeInventory').classList.contains('active')) {
                        this.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.locked = document.pointerLockElement !== null;
                });

                for (let i = 1; i <= 5; i++) {
                    document.addEventListener('keydown', (e) => {
                        if (e.key === i.toString()) {
                            this.player.selectSlot(i - 1);
                        }
                    });
                }
            }

            onKeyDown(e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    if (this.game.currentMode && this.game.currentMode.name === 'Creative') {
                        this.game.toggleCreativeInventory();
                    }
                    return;
                }

                if (e.key === 'Escape') {
                    if (document.getElementById('creativeInventory').classList.contains('active')) {
                        this.game.toggleCreativeInventory();
                        return;
                    }
                    this.game.togglePause();
                    return;
                }

                if (document.getElementById('creativeInventory').classList.contains('active')) return;

                this.keys[e.key.toLowerCase()] = true;

                if (e.key === 'w') this.player.move('forward');
                if (e.key === 's') this.player.move('back');
                if (e.key === 'a') this.player.move('left');
                if (e.key === 'd') this.player.move('right');
                
                if (e.key === ' ') {
                    if (this.player.flying) {
                        this.player.velocity.y = 0.3;
                    } else {
                        this.player.jump();
                    }
                }
                
                if (e.key === 'Shift' && this.player.flying) {
                    this.player.velocity.y = -0.3;
                }

                if (e.key === 'f' && this.player.mode.allowFlying) {
                    this.player.toggleFly();
                }
            }

            onKeyUp(e) {
                this.keys[e.key.toLowerCase()] = false;
            }

            onMouseDown(e) {
                if (!this.locked) return;
                
                this.mouseDown = true;

                if (e.button === 0) {
                    this.player.breakBlock();
                } else if (e.button === 2) {
                    e.preventDefault();
                    this.player.placeBlock();
                }
            }

            onMouseMove(e) {
                if (!this.locked) return;

                const sensitivity = 0.0012;
                this.player.rotation.y -= e.movementX * sensitivity;
                this.player.rotation.x -= e.movementY * sensitivity;
                this.player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.player.rotation.x));
            }

            onWheel(e) {
                if (!this.locked) return;
                const direction = Math.sign(e.deltaY);
                if (direction > 0) {
                    this.player.selectSlot((this.player.selectedSlot + 1) % 5);
                } else if (direction < 0) {
                    this.player.selectSlot((this.player.selectedSlot - 1 + 5) % 5);
                }
            }

            requestPointerLock() {
                document.body.requestPointerLock();
            }

            exitPointerLock() {
                document.exitPointerLock();
            }

            dispose() {}
        }

        // ===========================================
        // INITIALIZE GAME
        // ===========================================
        window.game = new Game();

        document.addEventListener('contextmenu', e => e.preventDefault());

        let lastTime = performance.now();
        let frames = 0;
        setInterval(() => {
            const now = performance.now();
            const fps = Math.round(frames * 1000 / (now - lastTime));
            document.getElementById('fpsInfo').textContent = fps;
            frames = 0;
            lastTime = now;
        }, 1000);
        
        function countFrame() {
            frames++;
            requestAnimationFrame(countFrame);
        }
        countFrame();
    </script>
</body>
</html>